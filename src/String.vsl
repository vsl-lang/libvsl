const STRING_DEALLOC_OPT_OUT: UInt8 = 1 << 0;

// A string represents some section of text. A string can represent a single
// character or an entire file. That said, it is important to understand when
// to use strings compared to other types. If you were to read a large file into
// a string you would eat ungodly amounts of memory so for this purpose you may
// want to reference the File class.
//
// VSL strings are **immutable**. This means that you can't really 'modify' a
// string, you must create a new one. This is automatically done with string
// methods and operators such as `+`.
//
// A good question is what happens with these old strings. VSL, unlike many
// other compiled languages, uses automatic memory management. This means that
// VSL will intelligently determine when to clean up old strings. That said,
// automatic memory management is not magic and it is reccomended not to
// construct strings in large loops. For this purpose use the string methods
// which have internal optimizations.
//
// Internally strings are represented as their length and their value as a null-
// terminated UInt8 array. You can access these underlying methods using
// self.underlyingData and self.byteLength however this is reccomended against
// as in other implementations for other platforms these may not be available.
// Additionally use caution when using these, modifying any of these values can
// result in segfaults. If you are passing the underlyingData to a function
// which may modify it, create a copy of the underlyingData before you use it.
@primitive(String, _precType)
@dynamic(false)
public class String {

    // NOTE: Positioning of first couple fields is very important. Usually
    // this will be compiled as if it is in the format of
    //     struct libvsl.String {
    //         uint8_t options;
    //         size_t length;
    //         char* value;
    //     }
    // if you change these then you won't get a sane string.

    private const options: UInt8 = 0
    private const byteLength: UInt
    const underlyingData: Pointer<UInt8>

    // Using this intializer REQUIRES a Pointer that is allocated by VSL. As a
    // result this class WILL take control of the management for the data. To
    // prevent this you will need to set the STRING_DEALLOC_OPT_OUT bit which
    // can be done using the [String#deallocOptOut] function.
    public init(value: Pointer<UInt8>, byteLength: UInt) {
        self.underlyingData = value
        self.byteLength = byteLength
    }

    // Creates a substring from a string. This slices a string 0-indexed from
    // [start, end). Negative parameters refer to the end of the array. This
    // means `-1` will refer to just before the last item.
    public func substring(from startIndex: Int, to endIndex: Int) -> String {
        if startIndex > self.byteLength {
            return ""
        }

        if startIndex < 0 {
            startIndex = Int::self.byteLength + startIndex
        }

        if endIndex < 0 {
            endIndex = Int::self.byteLength + endIndex
        }

        if endIndex <= startIndex {
            return ""
        }

        let newLength = min(endIndex - startIndex, self.byteLength)
        let newPtr = Pointer<UInt8>.alloc(UInt64::newLength)

        self.underlyingData
            .offset(by: startIndex)
            .copy(to: newPtr, count: UInt64::newLength)

        return String(value: newPtr, byteLength: UInt::newLength)
    }

    // Substrings from a given point to the end of the string. A negative number
    // as a parameter is invalid. Use `String.tail` if you wish for that. If a
    // number zero or less is passed an empty string will be returned.
    // Alternatively if the given point is past the index at the end of the
    // string, an empty string will be returned.
    public func substring(from index: Int) -> String {
        if index < 0 || index >= self.byteLength {
            return ""
        }

        return self.substring(from: index, to: self.byteLength)
    }

    // Prevents the backing pointer from being deallocated by VSL.
    public func deallocOptOut() {
        self.options |= STRING_DEALLOC_OPT_OUT;
    }

    deinit {
        if self.options & STRING_DEALLOC_OPT_OUT == 0 {
            self.underlyingData.free()
        }
    }

    // Concatenate two strings together.
    public static func +(lhs: String, rhs: String) -> String {
        let newLength: UInt = lhs.byteLength + rhs.byteLength

        let newPtr = Pointer<UInt8>.alloc(count: UInt64::(newLength + 1));

        // Copy the current string to a new location
        newPtr.copy(from: ByteSequence::lhs.underlyingData, length: UInt64::lhs.byteLength)

        // Copy the second string
        newPtr
            .offset(by: Int64::lhs.byteLength)
            .copy(from: ByteSequence::rhs.underlyingData, length: UInt64::rhs.byteLength)

        newPtr
            .offset(by: Int64::newLength)
            .store(value: 0)

        return String(value: newPtr, byteLength: lhs.byteLength + rhs.byteLength)
    }
}
