const STRING_DEALLOC_OPT_OUT: UInt8 = 1 << 0;

private func strlen(string: Pointer<UInt8>) -> UInt external(strlen);

// A string represents some section of text. A string can represent a single
// character or an entire file. That said, it is important to understand when
// to use strings compared to other types. If you were to read a large file into
// a string you would eat ungodly amounts of memory so for this purpose you may
// want to reference the File class.
//
// VSL strings are **immutable**. This means that you can't really 'modify' a
// string, you must create a new one. This is automatically done with string
// methods and operators such as `+`.
//
// A good question is what happens with these old strings. VSL, unlike many
// other compiled languages, uses automatic memory management. This means that
// VSL will intelligently determine when to clean up old strings. That said,
// automatic memory management is not magic and it is reccomended not to
// construct strings in large loops. For this purpose use the string methods
// which have internal optimizations.
//
// Internally strings are represented as their length and their value as a null-
// terminated UInt8 array. You can access these underlying methods using
// self.underlyingData and self.byteLength however this is reccomended against
// as in other implementations for other platforms these may not be available.
// Additionally use caution when using these, modifying any of these values can
// result in segfaults. If you are passing the underlyingData to a function
// which may modify it, create a copy of the underlyingData before you use it.
@primitive(String, _precType)
@dynamic(false)
public class String {

    // NOTE: Positioning of first couple fields is very important. Usually
    // this will be compiled as if it is in the format of
    //     struct libvsl.String {
    //         uint8_t options;
    //         size_t length;
    //         char* value;
    //     }
    // if you change these then you won't get a sane string.

    private const options: UInt8 = 0
    private const byteLength: UInt
    const underlyingData: Pointer<UInt8>

    /// Using this intializer REQUIRES a Pointer that is allocated by VSL. As a
    /// result this class WILL take control of the management for the data. To
    /// prevent this you will need to set the STRING_DEALLOC_OPT_OUT bit which
    /// can be done using the [String#deallocOptOut] function.
    public init(value: Pointer<UInt8>, byteLength: UInt) {
        self.underlyingData = value
        self.byteLength = byteLength
    }

    /// Creates from a pointer that is not allocated by VSL. This is the same
    /// as the other initializers except it already sets the
    /// STRING_DEALLOC_OPT_OUT bit.
    public init(externalValue value: Pointer<UInt8>, byteLength: UInt) {
        self.options |= STRING_DEALLOC_OPT_OUT;
        self.underlyingData = value
        self.byteLength = byteLength
    }

    /// Creates from a pointer that is not allocated by VSL. This is the same
    /// as the other initializers except it already sets the
    /// STRING_DEALLOC_OPT_OUT bit. This also automatically calculates the string
    /// length using the `strlen` function,
    public init(externalValue value: Pointer<UInt8>) {
        self.options |= STRING_DEALLOC_OPT_OUT;
        self.underlyingData = value
        self.byteLength = strlen(string: value)
    }

    /// Using this intializer REQUIRES a Pointer that is allocated by VSL. As a
    /// result this class WILL take control of the management for the data. To
    /// prevent this you will need to set the STRING_DEALLOC_OPT_OUT bit which
    /// can be done using the [String#deallocOptOut()] function.
    ///
    /// This will calculate the string length of `value` until the first
    /// null-byte encountered.
    public init(value: Pointer<UInt8>) {
        self.underlyingData = value
        self.byteLength = strlen(string: value)
    }

    /// Creates a substring from a string. This slices a string 0-indexed from
    /// [start, end). Negative parameters refer to the end of the array. This
    /// means `-1` will refer to just before the last item.
    public func substring(from startIndex: Int, to endIndex: Int) -> String {
        if startIndex > Int::self.byteLength {
            return ""
        }

        let normalizedStartIndex = startIndex < 0 ? Int::self.byteLength + startIndex : startIndex
        let normalizedEndIndex = endIndex < 0 ? Int::self.byteLength + endIndex : endIndex

        if normalizedEndIndex <= normalizedStartIndex {
            return ""
        }

        let newLength = min(normalizedEndIndex - normalizedStartIndex, Int::self.byteLength)
        let newPtr = Pointer<UInt8>.alloc(UInt64::newLength)

        self.underlyingData
            .offset(by: Int64::normalizedStartIndex)
            .copy(to: newPtr, count: UInt64::newLength)

        return String(value: newPtr, byteLength: UInt::newLength)
    }

    /// Substrings from a given point to the end of the string. A negative number
    /// as a parameter is invalid. Use `String.tail` if you wish for that. If a
    /// number zero or less is passed an empty string will be returned.
    /// Alternatively if the given point is past the index at the end of the
    /// string, an empty string will be returned.
    public func substring(from index: Int) -> String {
        if index < 0 || index >= Int::self.byteLength {
            return ""
        }

        return self.substring(from: index, to: Int::self.byteLength)
    }

    /// Obtains the first n characters from a string. This is identical to
    /// calling [String#substring(from:to:)] with `from: 0`.
    public func head(to index: Int) -> String {
        return self.substring(from: 0, to: index)
    }

    /// Obtains the last n characters from a string.
    public func tail(to index: Int) -> String {
        return self.substring(from: -index, to: Int::self.byteLength)
    }

    /// Prevents the backing pointer from being deallocated by VSL. Use this if
    /// you get the value from an external source
    public func deallocOptOut() {
        self.options |= STRING_DEALLOC_OPT_OUT;
    }

    deinit {
        if self.options & STRING_DEALLOC_OPT_OUT == 0 {
            self.underlyingData.free()
        }
    }

    // Concatenate two strings together.
    public static func +(lhs: String, rhs: String) -> String {
        let newLength: UInt = lhs.byteLength + rhs.byteLength

        let newPtr = Pointer<UInt8>.alloc(count: UInt64::(newLength + 1));

        // Copy the current string to a new location
        newPtr.copy(from: ByteSequence::lhs.underlyingData, length: UInt64::lhs.byteLength)

        // Copy the second string
        newPtr
            .offset(by: Int64::lhs.byteLength)
            .copy(from: ByteSequence::rhs.underlyingData, length: UInt64::rhs.byteLength)

        newPtr
            .offset(by: Int64::newLength)
            .store(value: 0)

        return String(value: newPtr, byteLength: lhs.byteLength + rhs.byteLength)
    }
}
