const ARRAY_DEALLOC_OPT_OUT: UInt8 = 1 << 0;

// The array class represents a dynamically-scaled mutable list of items.
@dynamic(false)
@primitive(List)
public class Array<Type> {

    // Array options
    private let options: UInt8 = 0

    // Internal capacity of the array
    private let capacity: UInt

    // Length of the physical content
    private let contentLength: UInt

    // Pointer to  the data
    private let data: Pointer<Type>

    /// Gets the length of the array
    public let length: Int {
        return Int::contentLength
    }

    /// Create an empty array with a given internal capacity. You can use
    public init(initialCapacity: UInt) {
        self.capacity = initialCapacity
        self.contentLength = 0
        self.data = Pointer<Type>.alloc(count: UInt64::initialCapacity)
    }

    /// Create an array from a C-style array/pointer with a given length, if
    /// the length of pointer is invalid behavior is undefined. Deallocation is
    /// opted out by default with this.
    public init(cArray: Pointer<Type>, length: UInt) {
        self.capacity = length
        self.contentLength = length
        self.data = cArray

        self.options |= ARRAY_DEALLOC_OPT_OUT
    }

    /// Appends an element to the end of the array
    public func append(element: Type) -> Void {
        if self.contentLength == self.capacity {
            self.reallocateArray()
        }

        self.data
            .offset(by: Int64::self.contentLength)
            .store(value: element)

        self.contentLength += 1
    }

    /// Prepends an element to the beginning of the array
    public func prepend(element: Type) -> Void {
        if self.contentLength == self.capacity {
            self.reallocateArray()
        }

        self.data
            .move(to: self.data.offset(by: 1), count: UInt64::self.contentLength)

        self.data.store(value: element)
        self.contentLength += 1
    }

    // Expand array capacity
    private func reallocateArray() -> Void {
        self.capacity *= 2

        // If ARRAY_DEALLOC_OPT_OUT is true then we will have to create a new
        // pointer
        if self.options & ARRAY_DEALLOC_OPT_OUT != 0 {
            self.data = Pointer<Type>.alloc(count: UInt64::self.capacity)
            self.options ^= ARRAY_DEALLOC_OPT_OUT;
        } else {
            self.data = self.data.realloc(count: UInt64::self.capacity)
        }
    }

    deinit {
        if self.options & ARRAY_DEALLOC_OPT_OUT == 0 {
            self.data.free()
        }
    }
}
